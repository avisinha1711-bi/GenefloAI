// Enhanced Memory System
class EnhancedMemory {
  constructor() {
    this.conversationMemory = new Map();
    this.conceptMemory = new Map();
    this.userModels = new Map();
  }

  storeConversation(userId, message, response, timestamp) {
    if (!this.conversationMemory.has(userId)) {
      this.conversationMemory.set(userId, []);
    }
    
    const conversation = this.conversationMemory.get(userId);
    conversation.push({
      role: 'user',
      content: message,
      timestamp
    });
    
    conversation.push({
      role: 'assistant',
      content: response,
      timestamp
    });
    
    // Keep only last 50 messages
    if (conversation.length > 50) {
      this.conversationMemory.set(userId, conversation.slice(-50));
    }
  }

  learnConcept(userId, concept, confidence = 1) {
    if (!this.conceptMemory.has(userId)) {
      this.conceptMemory.set(userId, new Map());
    }
    
    const userConcepts = this.conceptMemory.get(userId);
    const currentConfidence = userConcepts.get(concept) || 0;
    userConcepts.set(concept, Math.min(1, currentConfidence + confidence * 0.1));
  }

  getRelevantMemories(userId, currentMessage, limit = 5) {
    const conversation = this.conversationMemory.get(userId) || [];
    const concepts = this.conceptMemory.get(userId) || new Map();
    
    const relevantMemories = conversation
      .filter(msg => msg.role === 'user')
      .slice(-limit)
      .map(msg => msg.content);
    
    const strongConcepts = Array.from(concepts.entries())
      .filter(([_, confidence]) => confidence > 0.7)
      .map(([concept]) => concept);
    
    return {
      recentConversations: relevantMemories,
      knownConcepts: strongConcepts
    };
  }

  // Clear memory for a user (for deployment compatibility)
  clearUserMemory(userId) {
    this.conversationMemory.delete(userId);
    this.conceptMemory.delete(userId);
  }
}

// Adaptive Learning Engine
class AdaptiveLearningEngine {
  constructor() {
    this.knowledgeGraph = new Map();
    this.initializeKnowledgeGraph();
  }

  initializeKnowledgeGraph() {
    // Pre-defined knowledge graph - no dynamic imports
    const concepts = {
      'mutations': {
        name: 'Mutations',
        prerequisites: [],
        difficulty: 'beginner',
        related: ['point_mutations', 'deletions', 'insertions']
      },
      'genetic_recombination': {
        name: 'Genetic Recombination',
        prerequisites: ['mutations'],
        difficulty: 'intermediate',
        related: ['heteroduplexes', 'branch_migration', 'recombination_frequency']
      },
      'genetic_mapping': {
        name: 'Genetic Mapping',
        prerequisites: ['genetic_recombination'],
        difficulty: 'intermediate',
        related: ['recombination_frequency', 'deletion_mapping', 'chromosome_mapping']
      },
      'complementation': {
        name: 'Complementation',
        prerequisites: ['mutations'],
        difficulty: 'beginner',
        related: ['cis_trans', 'dominant_recessive']
      },
      'transposable_elements': {
        name: 'Transposable Elements',
        prerequisites: ['mutations'],
        difficulty: 'advanced',
        related: ['IS_elements', 'transposons', 'retrotransposons']
      },
      'genetic_engineering': {
        name: 'Genetic Engineering',
        prerequisites: ['mutations', 'genetic_recombination'],
        difficulty: 'advanced',
        related: ['recombinant_dna', 'cloning', 'restriction_enzymes']
      }
    };

    this.knowledgeGraph = new Map(Object.entries(concepts));
  }

  assessKnowledgeLevel(userSession, currentMessage) {
    const conversationHistory = userSession.conversationHistory || [];
    const knowledgeLevel = userSession.knowledgeLevel || 3;
    
    const understandingScore = this.analyzeUnderstanding(conversationHistory);
    const questionComplexity = this.analyzeQuestionComplexity(currentMessage);
    
    let newLevel = knowledgeLevel;
    if (understandingScore > 0.8 && questionComplexity === 'high') {
      newLevel = Math.min(5, knowledgeLevel + 0.1);
    } else if (understandingScore < 0.4) {
      newLevel = Math.max(1, knowledgeLevel - 0.1);
    }
    
    return newLevel;
  }

  personalizeExplanation(concept, knowledgeLevel) {
    // Pre-defined explanations - no dynamic content
    const explanations = {
      'mutations': {
        1: "Mutations are changes in DNA sequence that can affect how genes work.",
        2: "Mutations include point mutations, deletions, and insertions that alter DNA.",
        3: "Point mutations can be transitions or transversions, while frameshift mutations alter reading frames.",
        4: "Mutations are classified by effects: silent, missense, nonsense, or frameshift with specific repair mechanisms.",
        5: "Mutation mechanisms include tautomeric shifts and replication errors balanced between adaptation and stability."
      },
      'genetic_recombination': {
        1: "Genetic recombination mixes DNA from different sources creating new gene combinations.",
        2: "Recombination involves breaking and rejoining DNA during meiosis or bacterial exchange.",
        3: "Holliday model explains recombination through strand invasion and branch migration.",
        4: "Recombination frequency measures genetic distance with specific protein mechanisms.",
        5: "Molecular mechanisms include single-strand invasion and double Holliday junction resolution."
      }
    };

    const level = Math.min(5, Math.max(1, Math.round(knowledgeLevel)));
    return explanations[concept]?.[level] || `I'll explain ${concept} at knowledge level ${level}.`;
  }

  analyzeUnderstanding(conversationHistory) {
    let score = 0.5;
    const recentMessages = conversationHistory.slice(-10);
    
    // Simple analysis without complex processing
    const confusionCount = recentMessages.filter(msg => 
      msg.message && typeof msg.message === 'string' && 
      (msg.message.toLowerCase().includes('?') || 
       msg.message.toLowerCase().includes('confused') ||
       msg.message.toLowerCase().includes('don\'t understand'))
    ).length;
    
    const understandingCount = recentMessages.filter(msg => 
      msg.message && typeof msg.message === 'string' &&
      (msg.message.toLowerCase().includes('understand') ||
       msg.message.toLowerCase().includes('clear') ||
       msg.message.toLowerCase().includes('thanks'))
    ).length;
    
    score += (understandingCount - confusionCount) * 0.1;
    return Math.max(0.1, Math.min(1, score));
  }

  analyzeQuestionComplexity(question) {
    if (typeof question !== 'string') return 'medium';
    
    const lowerQuestion = question.toLowerCase();
    const beginnerKeywords = ['what is', 'basic', 'simple', 'define'];
    const advancedKeywords = ['mechanism', 'regulation', 'molecular', 'detailed'];
    
    if (advancedKeywords.some(keyword => lowerQuestion.includes(keyword))) {
      return 'high';
    } else if (beginnerKeywords.some(keyword => lowerQuestion.includes(keyword))) {
      return 'low';
    }
    return 'medium';
  }

  getSuggestedConcepts(currentConcept, knowledgeLevel) {
    const concept = this.knowledgeGraph.get(currentConcept);
    if (!concept) return [];
    
    return concept.related.slice(0, Math.max(2, Math.floor(knowledgeLevel)));
  }
}

// Reasoning Engine
class ReasoningEngine {
  constructor() {
    this.factBase = this.initializeFactBase();
  }

  initializeFactBase() {
    // Static fact base - no external dependencies
    return {
      'mutations': {
        description: 'DNA sequence changes that create genetic variation',
        types: ['point_mutations', 'deletions', 'insertions', 'frameshift'],
        concept: 'mutations'
      },
      'genetic_recombination': {
        description: 'Process of breaking and rejoining DNA to create new gene combinations',
        mechanisms: ['homologous', 'site_specific', 'transposition'],
        concept: 'genetic_recombination'
      },
      'genetic_mapping': {
        description: 'Determining relative positions of genes on chromosomes',
        methods: ['recombination_frequency', 'deletion_mapping', 'physical_mapping'],
        concept: 'genetic_mapping'
      }
    };
  }

  async generateReasonedResponse(message, context, userSession) {
    try {
      // Step 1: Analyze query intent
      const intent = this.analyzeIntent(message);
      
      // Step 2: Retrieve relevant facts
      const relevantFacts = this.retrieveRelevantFacts(message, context);
      
      // Step 3: Generate reasoning chain
      const reasoningSteps = this.buildReasoningChain(message, relevantFacts, userSession, intent);
      
      // Step 4: Formulate response
      const answer = this.formulateAnswer(message, reasoningSteps, userSession.knowledgeLevel, relevantFacts);
      
      return {
        answer: answer,
        reasoning: reasoningSteps,
        conceptsUsed: relevantFacts.map(fact => fact.concept),
        intent: intent
      };
    } catch (error) {
      console.error('Reasoning engine error:', error);
      return {
        answer: "I encountered an error processing your genetics question. Please try again.",
        reasoning: ['Error in reasoning process'],
        conceptsUsed: [],
        intent: 'error'
      };
    }
  }

  analyzeIntent(message) {
    if (typeof message !== 'string') return 'general_information';
    
    const lowerMessage = message.toLowerCase();
    
    if (lowerMessage.includes('how') || lowerMessage.includes('process')) {
      return 'process_explanation';
    } else if (lowerMessage.includes('difference between') || lowerMessage.includes('compare')) {
      return 'comparison';
    } else if (lowerMessage.includes('why')) {
      return 'reasoning';
    } else if (lowerMessage.includes('what is') || lowerMessage.includes('define')) {
      return 'definition';
    } else {
      return 'general_information';
    }
  }

  buildReasoningChain(question, facts, userSession, intent) {
    const steps = [];
    
    steps.push(`User question: "${question}"`);
    steps.push(`Detected intent: ${intent}`);
    steps.push(`User knowledge level: ${userSession.knowledgeLevel.toFixed(1)}`);
    
    if (facts.length > 0) {
      steps.push(`Found ${facts.length} relevant genetics facts`);
    }
    
    steps.push(`Adapting explanation complexity`);
    
    return steps;
  }

  formulateAnswer(question, reasoningSteps, knowledgeLevel, relevantFacts) {
    if (typeof question !== 'string') {
      return "Please ask a question about genetics.";
    }
    
    const lowerQuestion = question.toLowerCase();
    
    // Determine which genetics concept is being asked about
    let primaryConcept = 'mutations'; // default
    if (lowerQuestion.includes('recombination')) {
      primaryConcept = 'genetic_recombination';
    } else if (lowerQuestion.includes('mapping')) {
      primaryConcept = 'genetic_mapping';
    } else if (lowerQuestion.includes('complementation')) {
      primaryConcept = 'complementation';
    } else if (lowerQuestion.includes('transpos')) {
      primaryConcept = 'transposable_elements';
    } else if (lowerQuestion.includes('genetic engineering')) {
      primaryConcept = 'genetic_engineering';
    }
    
    // Use learning engine for personalized response
    const learningEngine = new AdaptiveLearningEngine();
    
    let response = learningEngine.personalizeExplanation(primaryConcept, knowledgeLevel);
    
    // Add context based on intent
    const intent = this.analyzeIntent(question);
    if (intent === 'process_explanation') {
      response += ` This process involves specific genetic mechanisms that ensure accuracy.`;
    }
    
    return response;
  }

  retrieveRelevantFacts(message, context) {
    if (typeof message !== 'string') return [];
    
    const keywords = message.toLowerCase().split(' ');
    const relevantFacts = [];
    
    for (const [concept, fact] of Object.entries(this.factBase)) {
      const factText = JSON.stringify(fact).toLowerCase();
      if (keywords.some(keyword => 
        factText.includes(keyword) ||
        concept.includes(keyword)
      )) {
        relevantFacts.push({ concept, ...fact });
      }
    }
    
    return relevantFacts;
  }
}

// Export for CommonJS (deployment compatibility)
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { EnhancedMemory, AdaptiveLearningEngine, ReasoningEngine };
}

// Export for ES modules (if needed)
if (typeof window !== 'undefined') {
  window.GeneticsAI = { EnhancedMemory, AdaptiveLearningEngine, ReasoningEngine };
}
