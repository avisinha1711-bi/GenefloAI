// Enhanced Memory System
class EnhancedMemory {
  constructor() {
    this.conversationMemory = new Map();
    this.conceptMemory = new Map();
    this.userModels = new Map();
  }

  storeConversation(userId, message, response, timestamp) {
    if (!this.conversationMemory.has(userId)) {
      this.conversationMemory.set(userId, []);
    }
    
    const conversation = this.conversationMemory.get(userId);
    conversation.push({
      role: 'user',
      content: message,
      timestamp
    });
    
    conversation.push({
      role: 'assistant',
      content: response,
      timestamp
    });
    
    // Keep only last 50 messages
    if (conversation.length > 50) {
      this.conversationMemory.set(userId, conversation.slice(-50));
    }
  }

  learnConcept(userId, concept, confidence = 1) {
    if (!this.conceptMemory.has(userId)) {
      this.conceptMemory.set(userId, new Map());
    }
    
    const userConcepts = this.conceptMemory.get(userId);
    const currentConfidence = userConcepts.get(concept) || 0;
    userConcepts.set(concept, Math.min(1, currentConfidence + confidence * 0.1));
  }

  getRelevantMemories(userId, currentMessage, limit = 5) {
    const conversation = this.conversationMemory.get(userId) || [];
    const concepts = this.conceptMemory.get(userId) || new Map();
    
    const relevantMemories = conversation
      .filter(msg => msg.role === 'user')
      .slice(-limit)
      .map(msg => msg.content);
    
    const strongConcepts = Array.from(concepts.entries())
      .filter(([_, confidence]) => confidence > 0.7)
      .map(([concept]) => concept);
    
    return {
      recentConversations: relevantMemories,
      knownConcepts: strongConcepts
    };
  }
}

// Adaptive Learning Engine
class AdaptiveLearningEngine {
  constructor() {
    this.knowledgeGraph = new Map();
    this.initializeKnowledgeGraph();
  }

  initializeKnowledgeGraph() {
    const concepts = {
      'dna_structure': {
        name: 'DNA Structure',
        prerequisites: [],
        difficulty: 'beginner',
        related: ['base_pairing', 'double_helix']
      },
      'transcription': {
        name: 'Transcription',
        prerequisites: ['dna_structure'],
        difficulty: 'intermediate',
        related: ['rna_polymerase', 'promoter']
      },
      'translation': {
        name: 'Translation',
        prerequisites: ['transcription', 'genetic_code'],
        difficulty: 'intermediate',
        related: ['ribosome', 'trna', 'codon']
      },
      'genetic_code': {
        name: 'Genetic Code',
        prerequisites: ['dna_structure'],
        difficulty: 'beginner',
        related: ['codon', 'amino_acid']
      },
      'gene_expression': {
        name: 'Gene Expression',
        prerequisites: ['transcription', 'translation'],
        difficulty: 'advanced',
        related: ['regulation', 'epigenetics']
      }
    };

    this.knowledgeGraph = new Map(Object.entries(concepts));
  }

  assessKnowledgeLevel(userSession, currentMessage) {
    const conversationHistory = userSession.conversationHistory || [];
    const knowledgeLevel = userSession.knowledgeLevel || 3;
    
    const understandingScore = this.analyzeUnderstanding(conversationHistory);
    const questionComplexity = this.analyzeQuestionComplexity(currentMessage);
    
    let newLevel = knowledgeLevel;
    if (understandingScore > 0.8 && questionComplexity === 'high') {
      newLevel = Math.min(5, knowledgeLevel + 0.1);
    } else if (understandingScore < 0.4) {
      newLevel = Math.max(1, knowledgeLevel - 0.1);
    }
    
    return newLevel;
  }

  personalizeExplanation(concept, knowledgeLevel) {
    const explanations = {
      'dna_structure': {
        1: "DNA is like a twisted ladder with four chemical letters: A, T, C, G that carry genetic information.",
        2: "DNA has a double-helix structure where A pairs with T and C pairs with G through hydrogen bonds.",
        3: "The DNA double helix features complementary base pairing with anti-parallel strands running 5' to 3'.",
        4: "DNA structure includes major and minor grooves, with base stacking providing stability to the helix.",
        5: "The B-form DNA double helix has 10.5 base pairs per turn, with specific groove dimensions that facilitate protein binding."
      },
      'transcription': {
        1: "Transcription copies DNA into mRNA so the genetic message can leave the nucleus.",
        2: "RNA polymerase reads the DNA template and builds mRNA using complementary base pairing.",
        3: "Transcription involves initiation at promoter regions, elongation by RNA polymerase, and termination at specific sequences.",
        4: "Eukaryotic transcription requires transcription factors and results in pre-mRNA that undergoes processing.",
        5: "Transcription regulation involves enhancers, silencers, and chromatin remodeling complexes that control gene expression timing."
      },
      'translation': {
        1: "Translation reads mRNA to build proteins using the genetic code.",
        2: "Ribosomes match tRNA anticodons to mRNA codons to assemble amino acids into proteins.",
        3: "Translation occurs in initiation, elongation, and termination phases with specific factors at each stage.",
        4: "The process involves codon-anticodon recognition, peptidyl transferase activity, and ribosomal translocation.",
        5: "Translation regulation includes initiation factor phosphorylation, miRNA targeting, and ribosomal frameshifting mechanisms."
      },
      'genetic_code': {
        1: "The genetic code is how DNA instructions are read to make proteins.",
        2: "Three DNA letters (codon) specify one amino acid in the genetic code.",
        3: "The genetic code is degenerate, universal, and non-overlapping with start and stop signals.",
        4: "64 possible codons encode 20 amino acids with wobble base pairing in the third position.",
        5: "The genetic code exhibits context-dependent decoding and near-universality with minor variations in mitochondria."
      }
    };

    const level = Math.min(5, Math.max(1, Math.round(knowledgeLevel)));
    return explanations[concept]?.[level] || `I'll explain ${concept} at your knowledge level (${level}/5).`;
  }

  analyzeUnderstanding(conversationHistory) {
    let score = 0.5;
    const recentMessages = conversationHistory.slice(-10);
    const confusionIndicators = ['confused', 'don\'t understand', 'what does', 'explain again', '?', 'how come'];
    const understandingIndicators = ['I see', 'that makes sense', 'understood', 'thanks', 'clear', 'got it'];
    
    const confusionCount = recentMessages.filter(msg => 
      confusionIndicators.some(indicator => msg.message?.toLowerCase().includes(indicator))
    ).length;
    
    const understandingCount = recentMessages.filter(msg => 
      understandingIndicators.some(indicator => msg.message?.toLowerCase().includes(indicator))
    ).length;
    
    score += (understandingCount - confusionCount) * 0.1;
    return Math.max(0.1, Math.min(1, score));
  }

  analyzeQuestionComplexity(question) {
    const beginnerKeywords = ['what is', 'basic', 'simple', 'define'];
    const advancedKeywords = ['mechanism', 'regulation', 'specific', 'detailed', 'how does', 'why does'];
    
    if (advancedKeywords.some(keyword => question.toLowerCase().includes(keyword))) {
      return 'high';
    } else if (beginnerKeywords.some(keyword => question.toLowerCase().includes(keyword))) {
      return 'low';
    }
    return 'medium';
  }

  getSuggestedConcepts(currentConcept, knowledgeLevel) {
    const concept = this.knowledgeGraph.get(currentConcept);
    if (!concept) return [];
    
    return concept.related.slice(0, Math.max(2, Math.floor(knowledgeLevel)));
  }
}

// Reasoning Engine
class ReasoningEngine {
  constructor() {
    this.factBase = this.initializeFactBase();
  }

  initializeFactBase() {
    return {
      'dna_replication': {
        description: 'Process of DNA copying',
        steps: ['initiation', 'elongation', 'termination'],
        enzymes: ['DNA polymerase', 'helicase', 'ligase'],
        concept: 'dna_structure'
      },
      'central_dogma': {
        description: 'DNA → RNA → Protein',
        processes: ['replication', 'transcription', 'translation'],
        concept: 'gene_expression'
      },
      'protein_synthesis': {
        description: 'Process of creating proteins from DNA instructions',
        steps: ['transcription', 'translation'],
        concept: 'translation'
      },
      'gene_regulation': {
        description: 'Control of gene expression',
        mechanisms: ['transcriptional', 'post-transcriptional', 'translational', 'post-translational'],
        concept: 'gene_expression'
      }
    };
  }

  async generateReasonedResponse(message, context, userSession) {
    // Step 1: Analyze query intent
    const intent = this.analyzeIntent(message);
    
    // Step 2: Retrieve relevant facts
    const relevantFacts = this.retrieveRelevantFacts(message, context);
    
    // Step 3: Generate reasoning chain
    const reasoningSteps = this.buildReasoningChain(message, relevantFacts, userSession, intent);
    
    // Step 4: Formulate response
    const answer = this.formulateAnswer(message, reasoningSteps, userSession.knowledgeLevel, relevantFacts);
    
    return {
      answer: answer,
      reasoning: reasoningSteps,
      conceptsUsed: relevantFacts.map(fact => fact.concept),
      intent: intent
    };
  }

  analyzeIntent(message) {
    const lowerMessage = message.toLowerCase();
    
    if (lowerMessage.includes('how') || lowerMessage.includes('process') || lowerMessage.includes('steps')) {
      return 'process_explanation';
    } else if (lowerMessage.includes('difference between') || lowerMessage.includes('compare')) {
      return 'comparison';
    } else if (lowerMessage.includes('why') || lowerMessage.includes('reason')) {
      return 'reasoning';
    } else if (lowerMessage.includes('what is') || lowerMessage.includes('define')) {
      return 'definition';
    } else if (lowerMessage.includes('example') || lowerMessage.includes('instance')) {
      return 'example';
    } else {
      return 'general_information';
    }
  }

  buildReasoningChain(question, facts, userSession, intent) {
    const steps = [];
    
    steps.push(`User question: "${question}"`);
    steps.push(`Detected intent: ${intent}`);
    steps.push(`User knowledge level: ${userSession.knowledgeLevel.toFixed(1)}/5`);
    
    if (facts.length > 0) {
      steps.push(`Found ${facts.length} relevant facts:`);
      facts.forEach((fact, index) => {
        steps.push(`- ${fact.description}`);
      });
    } else {
      steps.push(`No specific facts found, using general knowledge`);
    }
    
    steps.push(`Adapting explanation complexity for knowledge level ${Math.round(userSession.knowledgeLevel)}`);
    
    return steps;
  }

  formulateAnswer(question, reasoningSteps, knowledgeLevel, relevantFacts) {
    const lowerQuestion = question.toLowerCase();
    
    // Determine which concept is being asked about
    let primaryConcept = 'general';
    if (lowerQuestion.includes('dna') && (lowerQuestion.includes('structure') || lowerQuestion.includes('replication'))) {
      primaryConcept = 'dna_structure';
    } else if (lowerQuestion.includes('transcription')) {
      primaryConcept = 'transcription';
    } else if (lowerQuestion.includes('translation') || lowerQuestion.includes('protein synthesis')) {
      primaryConcept = 'translation';
    } else if (lowerQuestion.includes('genetic code') || lowerQuestion.includes('codon')) {
      primaryConcept = 'genetic_code';
    } else if (lowerQuestion.includes('gene') && lowerQuestion.includes('expression')) {
      primaryConcept = 'gene_expression';
    }
    
    // Use learning engine for personalized response
    const learningEngine = new AdaptiveLearningEngine();
    learningEngine.initializeKnowledgeGraph();
    
    let response = learningEngine.personalizeExplanation(primaryConcept, knowledgeLevel);
    
    // Add context based on intent
    const intent = this.analyzeIntent(question);
    if (intent === 'process_explanation' && relevantFacts.length > 0) {
      const fact = relevantFacts[0];
      if (fact.steps) {
        response += `\n\nThe process involves these main steps: ${fact.steps.join(', ')}.`;
      }
    } else if (intent === 'comparison') {
      response += `\n\nWould you like me to compare this with related concepts?`;
    }
    
    return response;
  }

  retrieveRelevantFacts(message, context) {
    const keywords = message.toLowerCase().split(' ');
    const relevantFacts = [];
    
    for (const [concept, fact] of Object.entries(this.factBase)) {
      const factText = JSON.stringify(fact).toLowerCase();
      if (keywords.some(keyword => 
        factText.includes(keyword) ||
        concept.includes(keyword)
      )) {
        relevantFacts.push({ concept, ...fact });
      }
    }
    
    return relevantFacts;
  }
}

module.exports = { EnhancedMemory, AdaptiveLearningEngine, ReasoningEngine };
